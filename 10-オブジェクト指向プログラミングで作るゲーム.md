# オブジェクト指向プログラミングで作るゲーム

## オブジェクト指向プログラミングについて

オブジェクト指向プログラミングの二種類の語られ方

- オブジェクト同士の相互作用やメッセージングの特徴に重きをおいた議論
- ユーザー定義型の特徴に重きをおいた議論
  - 後者を解説

- クラスベースのオブジェクト指向プログラミングの特色
  - カプセル化
  - 継承
  - 多態性

## クラスについて

クラス：複数のオブジェクトを作るためのひな形
インスタンス：クラスから作った実体のこと

- たい焼きの型とたい焼き
- 自動車の設計図と自動車

- メンバー：フィールドとメソッドを合わせたもの
  - フィールド：状態
  - メソッド：メソッド

コンストラクタ：インスタンスを作成するメソッドのようなもの。``new``というキーワードと共に呼び出される

```scala
class クラス名(コンストラクタ引数1: コンストラクタ引数1の型, コンストラクタ引数2: コンストラクタ引数2の型, ...) {
  0個以上のフィールドの定義またはメソッド定義
}

class Cat(/* コンストラクタ引数 */name: String) {

  // メソッドの定義
  def greet(): Unit = println(s"僕、${name}")

}

// val cat = new Cat("ニャン太")
// cat.greet
  // cat: Cat = Cat@2eea88a1
  // 僕、ニャン太
```

ハッシュコード：インスタンスにはハッシュコードが割り当てられ、これによって識別される。

インスタンスの作成：``new クラス名(コンストラクタ引数)``

フィールドの公開：コンストラクタ引数に、変数宣言を与えることでフィールドを公開できる。(フィールドを公開すると、インスタンスから呼び出すことができる)

```scala
class Cat(val name: String) {

  def greet(): Unit = println(s"僕、${name}")

}

// val cat = new Cat("ニャン太")
// cat.name
// フィールドを公開したことで、インスタンスからアクセスできるようになった
// このようにクラスはメンバーの外部への公開/非公開を好きなように設定できる
```

## カプセル化について

カプセル化：外部に公開するメンバーを制限すること。アクセスさせたくないフィールドやメソッドに``private``というアクセス修飾子をつけてカプセル化する。

```scala
class Cat(name: String) {

  private def greet(): Unit = println(s"僕、${name}")

}
```

カプセル化の重要性：ライブラリなど多くの利用者に利用されるクラスをつくる場合は、公開を制限しておいて、後々の編集を容易にすることができる。


## 多態性・継承

抽象クラス：継承して使うことが求められるクラスの宣言。インスタンス化はできない。

クラスの抽象化：``abstract class クラス名(コンストラクタ引数)``
クラスの継承：``class クラス名(コンストラクタ引数) extends 抽象クラス名``

is-aの関係：「BはAでもある」という関係のこと

is-aの関係であれば、抽象クラスのフィールドやメソッドをそのまま利用できる

```scala
abstract class Creature(var hitPoint: Int, var attackDamage: Int) {
  def isAlive(): Boolean = this.hitPoint > 0
}


class Hero(_hitPoint: Int, _attackDamage: Int) extends Creature(_hitPoint, _attackDamage) {
}
```

オーバーライド：継承元のメソッドの挙動を上書きすること。継承におけるテクニックのひとつ。

関数：``override def 関数名``
定数：``override val``

``toString``：JavaのObjectクラスにあるメソッド。したがって親クラスはJavaのObjectクラス。println関数の出力を、文字列として表示してくれる。

(Scalaにおけるすべてのclassは、AnyRef型で参照されるJavaのObjectというクラスを暗黙的に継承している)


多態性：抽象クラスを継承して、挙動の異なるクラスに派生するような性質のこと